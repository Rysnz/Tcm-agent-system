import uuid
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from django.http import StreamingHttpResponse
import json
from apps.chat.models import ChatSession, ChatMessage
from apps.chat.serializers import ChatSessionSerializer, ChatMessageSerializer
from apps.application.flow.workflow_manage import TCMWorkflowManager
from apps.application.models import Application
import logging

class ChatSessionViewSet(viewsets.ModelViewSet):
    queryset = ChatSession.objects.filter(is_delete=False)
    serializer_class = ChatSessionSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        application_id = self.request.query_params.get('application_id')
        if application_id:
            if application_id == 'default':
                application_id = 'e1ca5264-3589-11f0-a945-82469642f7d3'
            queryset = queryset.filter(application_id=application_id)
        return queryset
    
    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        if instance.is_delete:
            return Response(status=status.HTTP_404_NOT_FOUND)
        serializer = self.get_serializer(instance)
        return Response(serializer.data)
    
    def perform_create(self, serializer):
        serializer.save(user_id=self.request.user.id)

class ChatMessageViewSet(viewsets.ModelViewSet):
    queryset = ChatMessage.objects.filter(is_delete=False)
    serializer_class = ChatMessageSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        session_id = self.request.query_params.get('session_id')
        if session_id:
            queryset = queryset.filter(session_id=session_id)
        return queryset

class ChatView(APIView):
    
    def _convert_delta_to_message_chunk(self, delta):
        """转换delta对象为消息块，支持reasoning_content字段
        
        该函数用于处理模型返回的delta对象，提取其中的内容和思考过程
        
        Args:
            delta: 模型返回的delta对象
            
        Returns:
            dict: 包含message_chunk和reasoning_chunk的字典
        """
        from langchain_core.messages import AIMessageChunk
        from langchain_core.messages.tool import ToolMessageChunk
        from langchain_core.messages import SystemMessageChunk
        from langchain_core.messages import HumanMessageChunk
        
        message_chunk = None
        reasoning_chunk = None
        
        # 提取reasoning_content（思考过程）
        reasoning_content = getattr(delta, 'reasoning_content', None)
        if reasoning_content:
            reasoning_chunk = reasoning_content
        
        # 提取普通内容
        content = getattr(delta, 'content', None)
        if content:
            # 根据delta类型创建相应的消息块
            if isinstance(delta, AIMessageChunk):
                message_chunk = AIMessageChunk(content=content)
            elif isinstance(delta, ToolMessageChunk):
                message_chunk = ToolMessageChunk(content=content)
            elif isinstance(delta, SystemMessageChunk):
                message_chunk = SystemMessageChunk(content=content)
            elif isinstance(delta, HumanMessageChunk):
                message_chunk = HumanMessageChunk(content=content)
            else:
                message_chunk = AIMessageChunk(content=content)
        
        return {"message_chunk": message_chunk, "reasoning_chunk": reasoning_chunk}
    
    def post(self, request):
        try:
            # 确保所有必要的模型在所有执行路径中都可用
            from apps.chat.models import ChatSession, ChatMessage
            
            # 获取请求参数
            application_id = request.data.get('application_id')
            user_message = request.data.get('message', '')
            session_id = request.data.get('session_id')
            
            if not user_message:
                return Response(
                    {'error': 'message is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # 处理用户ID，未认证时生成临时UUID
            user_id = request.user.id if hasattr(request.user, 'id') and request.user.id else uuid.uuid4()
            
            # 检查是否使用默认应用ID
            is_default_app = application_id == 'default'
            
            # 处理application_id，对于默认应用，使用固定的UUID或获取第一个激活的应用
            if is_default_app:
                logger = logging.getLogger(__name__)
                try:
                    # 获取第一个激活的应用，按创建时间排序
                    default_app = Application.objects.filter(is_delete=False, is_active=True).order_by('create_time').first()
                    if default_app:
                        # 使用现有的默认应用
                        application_id = str(default_app.id)
                        logger.info(f"使用现有默认应用: {application_id}, 名称: {default_app.name}")
                    else:
                        # 如果没有现有应用，创建一个默认应用
                        logger.info(f"创建新的默认应用")
                        # 生成固定UUID，确保每次使用默认应用时保持一致
                        application_id = str(uuid.uuid5(uuid.NAMESPACE_OID, 'default-application'))
                        # 检查应用是否已存在
                        default_app, created = Application.objects.get_or_create(
                            id=application_id,
                            defaults={
                                'name': '默认应用',
                                'desc': '系统默认应用',
                                'user_id': user_id,
                                'is_active': True
                            }
                        )
                        logger.info(f"{'创建' if created else '使用'}默认应用: {application_id}, 名称: {default